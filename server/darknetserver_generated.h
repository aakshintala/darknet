// automatically generated by the FlatBuffers compiler, do not modify


#ifndef FLATBUFFERS_GENERATED_DARKNETSERVER_DARKNETSERVER_H_
#define FLATBUFFERS_GENERATED_DARKNETSERVER_DARKNETSERVER_H_

#include "flatbuffers/flatbuffers.h"

namespace darknetServer {

struct KeyFrame;

struct box;

struct DetectedObject;

struct DetectedObjects;

FLATBUFFERS_MANUALLY_ALIGNED_STRUCT(4) box FLATBUFFERS_FINAL_CLASS {
 private:
  float x_;
  float y_;
  float w_;
  float h_;

 public:
  box() {
    memset(this, 0, sizeof(box));
  }
  box(float _x, float _y, float _w, float _h)
      : x_(flatbuffers::EndianScalar(_x)),
        y_(flatbuffers::EndianScalar(_y)),
        w_(flatbuffers::EndianScalar(_w)),
        h_(flatbuffers::EndianScalar(_h)) {
  }
  float x() const {
    return flatbuffers::EndianScalar(x_);
  }
  float y() const {
    return flatbuffers::EndianScalar(y_);
  }
  float w() const {
    return flatbuffers::EndianScalar(w_);
  }
  float h() const {
    return flatbuffers::EndianScalar(h_);
  }
};
FLATBUFFERS_STRUCT_END(box, 16);

struct KeyFrame FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum {
    VT_WIDTH = 4,
    VT_HEIGHT = 6,
    VT_NUMCHANNELS = 8,
    VT_WIDTHSTEP = 10,
    VT_DATA = 12
  };
  int32_t width() const {
    return GetField<int32_t>(VT_WIDTH, 0);
  }
  int32_t height() const {
    return GetField<int32_t>(VT_HEIGHT, 0);
  }
  int32_t numChannels() const {
    return GetField<int32_t>(VT_NUMCHANNELS, 0);
  }
  int32_t widthStep() const {
    return GetField<int32_t>(VT_WIDTHSTEP, 0);
  }
  const flatbuffers::Vector<float> *data() const {
    return GetPointer<const flatbuffers::Vector<float> *>(VT_DATA);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int32_t>(verifier, VT_WIDTH) &&
           VerifyField<int32_t>(verifier, VT_HEIGHT) &&
           VerifyField<int32_t>(verifier, VT_NUMCHANNELS) &&
           VerifyField<int32_t>(verifier, VT_WIDTHSTEP) &&
           VerifyOffset(verifier, VT_DATA) &&
           verifier.VerifyVector(data()) &&
           verifier.EndTable();
  }
};

struct KeyFrameBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_width(int32_t width) {
    fbb_.AddElement<int32_t>(KeyFrame::VT_WIDTH, width, 0);
  }
  void add_height(int32_t height) {
    fbb_.AddElement<int32_t>(KeyFrame::VT_HEIGHT, height, 0);
  }
  void add_numChannels(int32_t numChannels) {
    fbb_.AddElement<int32_t>(KeyFrame::VT_NUMCHANNELS, numChannels, 0);
  }
  void add_widthStep(int32_t widthStep) {
    fbb_.AddElement<int32_t>(KeyFrame::VT_WIDTHSTEP, widthStep, 0);
  }
  void add_data(flatbuffers::Offset<flatbuffers::Vector<float>> data) {
    fbb_.AddOffset(KeyFrame::VT_DATA, data);
  }
  explicit KeyFrameBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  KeyFrameBuilder &operator=(const KeyFrameBuilder &);
  flatbuffers::Offset<KeyFrame> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<KeyFrame>(end);
    return o;
  }
};

inline flatbuffers::Offset<KeyFrame> CreateKeyFrame(
    flatbuffers::FlatBufferBuilder &_fbb,
    int32_t width = 0,
    int32_t height = 0,
    int32_t numChannels = 0,
    int32_t widthStep = 0,
    flatbuffers::Offset<flatbuffers::Vector<float>> data = 0) {
  KeyFrameBuilder builder_(_fbb);
  builder_.add_data(data);
  builder_.add_widthStep(widthStep);
  builder_.add_numChannels(numChannels);
  builder_.add_height(height);
  builder_.add_width(width);
  return builder_.Finish();
}

inline flatbuffers::Offset<KeyFrame> CreateKeyFrameDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    int32_t width = 0,
    int32_t height = 0,
    int32_t numChannels = 0,
    int32_t widthStep = 0,
    const std::vector<float> *data = nullptr) {
  return darknetServer::CreateKeyFrame(
      _fbb,
      width,
      height,
      numChannels,
      widthStep,
      data ? _fbb.CreateVector<float>(*data) : 0);
}

struct DetectedObject FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum {
    VT_BBOX = 4,
    VT_CLASSES = 6,
    VT_OBJECTNESS = 8,
    VT_SORT_CLASS = 10,
    VT_PROB = 12
  };
  const box *bbox() const {
    return GetStruct<const box *>(VT_BBOX);
  }
  int32_t classes() const {
    return GetField<int32_t>(VT_CLASSES, 0);
  }
  float objectness() const {
    return GetField<float>(VT_OBJECTNESS, 0.0f);
  }
  int32_t sort_class() const {
    return GetField<int32_t>(VT_SORT_CLASS, 0);
  }
  const flatbuffers::Vector<float> *prob() const {
    return GetPointer<const flatbuffers::Vector<float> *>(VT_PROB);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<box>(verifier, VT_BBOX) &&
           VerifyField<int32_t>(verifier, VT_CLASSES) &&
           VerifyField<float>(verifier, VT_OBJECTNESS) &&
           VerifyField<int32_t>(verifier, VT_SORT_CLASS) &&
           VerifyOffset(verifier, VT_PROB) &&
           verifier.VerifyVector(prob()) &&
           verifier.EndTable();
  }
};

struct DetectedObjectBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_bbox(const box *bbox) {
    fbb_.AddStruct(DetectedObject::VT_BBOX, bbox);
  }
  void add_classes(int32_t classes) {
    fbb_.AddElement<int32_t>(DetectedObject::VT_CLASSES, classes, 0);
  }
  void add_objectness(float objectness) {
    fbb_.AddElement<float>(DetectedObject::VT_OBJECTNESS, objectness, 0.0f);
  }
  void add_sort_class(int32_t sort_class) {
    fbb_.AddElement<int32_t>(DetectedObject::VT_SORT_CLASS, sort_class, 0);
  }
  void add_prob(flatbuffers::Offset<flatbuffers::Vector<float>> prob) {
    fbb_.AddOffset(DetectedObject::VT_PROB, prob);
  }
  explicit DetectedObjectBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  DetectedObjectBuilder &operator=(const DetectedObjectBuilder &);
  flatbuffers::Offset<DetectedObject> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<DetectedObject>(end);
    return o;
  }
};

inline flatbuffers::Offset<DetectedObject> CreateDetectedObject(
    flatbuffers::FlatBufferBuilder &_fbb,
    const box *bbox = 0,
    int32_t classes = 0,
    float objectness = 0.0f,
    int32_t sort_class = 0,
    flatbuffers::Offset<flatbuffers::Vector<float>> prob = 0) {
  DetectedObjectBuilder builder_(_fbb);
  builder_.add_prob(prob);
  builder_.add_sort_class(sort_class);
  builder_.add_objectness(objectness);
  builder_.add_classes(classes);
  builder_.add_bbox(bbox);
  return builder_.Finish();
}

inline flatbuffers::Offset<DetectedObject> CreateDetectedObjectDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    const box *bbox = 0,
    int32_t classes = 0,
    float objectness = 0.0f,
    int32_t sort_class = 0,
    const std::vector<float> *prob = nullptr) {
  return darknetServer::CreateDetectedObject(
      _fbb,
      bbox,
      classes,
      objectness,
      sort_class,
      prob ? _fbb.CreateVector<float>(*prob) : 0);
}

struct DetectedObjects FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum {
    VT_OBJECTS = 4
  };
  const flatbuffers::Vector<flatbuffers::Offset<DetectedObject>> *objects() const {
    return GetPointer<const flatbuffers::Vector<flatbuffers::Offset<DetectedObject>> *>(VT_OBJECTS);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_OBJECTS) &&
           verifier.VerifyVector(objects()) &&
           verifier.VerifyVectorOfTables(objects()) &&
           verifier.EndTable();
  }
};

struct DetectedObjectsBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_objects(flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<DetectedObject>>> objects) {
    fbb_.AddOffset(DetectedObjects::VT_OBJECTS, objects);
  }
  explicit DetectedObjectsBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  DetectedObjectsBuilder &operator=(const DetectedObjectsBuilder &);
  flatbuffers::Offset<DetectedObjects> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<DetectedObjects>(end);
    return o;
  }
};

inline flatbuffers::Offset<DetectedObjects> CreateDetectedObjects(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<DetectedObject>>> objects = 0) {
  DetectedObjectsBuilder builder_(_fbb);
  builder_.add_objects(objects);
  return builder_.Finish();
}

inline flatbuffers::Offset<DetectedObjects> CreateDetectedObjectsDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    const std::vector<flatbuffers::Offset<DetectedObject>> *objects = nullptr) {
  return darknetServer::CreateDetectedObjects(
      _fbb,
      objects ? _fbb.CreateVector<flatbuffers::Offset<DetectedObject>>(*objects) : 0);
}

}  // namespace darknetServer

#endif  // FLATBUFFERS_GENERATED_DARKNETSERVER_DARKNETSERVER_H_
